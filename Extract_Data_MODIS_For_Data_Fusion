var GPP = ee.ImageCollection("MODIS/006/MOD17A2H"),
    LST = ee.ImageCollection("MODIS/006/MYD11A2"),
    Area = ee.FeatureCollection("users/valeriofrank/Methods_Ecol_Evol/Study_Area"),
    pts_all = ee.FeatureCollection("users/valeriofrank/Methods_Ecol_Evol/Ground_Observations_All_2018_2021"),
    pts1 = ee.FeatureCollection("users/valeriofrank/Methods_Ecol_Evol/Ground_Observations_2017"),
    pts2 = ee.FeatureCollection("users/valeriofrank/Methods_Ecol_Evol/Ground_Observations_2018"),
    pts3 = ee.FeatureCollection("users/valeriofrank/Methods_Ecol_Evol/Ground_Observations_2019"),
    pts4 = ee.FeatureCollection("users/valeriofrank/Methods_Ecol_Evol/Ground_Observations_2020"),
    pts5 = ee.FeatureCollection("users/valeriofrank/Methods_Ecol_Evol/Ground_Observations_2021");

// The code is organised into four sub-steps:
// 1) The first sub-step demonstrates how retain and pre-process available imageries, in order to avoid 
//    high-level anomalous pixels, softening uncertainties prior Habitat Metrics calculation.

// 2) The second sub-step shows how to calculate Habitat Metrics for each available  multispectral imagery, 
//    and how to merge them with external products that differ in spatial and temporal resolution.

// 3) The third sub-step demonstrates how to extract values from metrics, in order to be spatially and 
//    temporally coincident with the collected telemetry/occurrence data, within the estabilished temporal 
//    window.

// 4) The fourth sub-step shows how merge the two collections composed of the extracted data frame and the  
//    original telemetry/occurrence spatial point dataframe.
  
  //Defining ground data collection and representative period
  var points = pts1;//User should repeat this step pts2, pts3, et√ß. Alternatively, the user can possibly run the entire dataset (pts_all)
  var start = "2017-01-01"; //Start of time period //Year/Month/Day/
  var end = "2017-12-31"; // End of time period
  
  // Renaming spectral bands and quality bands
  var GPPbands = ['Gpp'];
  var GPPband_names = ['GPP'];
  // Renaming spectral bands and quality bands
  var LSTbands = ['LST_Day_1km'];
  var LSTband_names = ['LST'];

  // Getting the multispectral imagery dataset in a defined temporal window.
  var GPPfiltered = GPP.filterDate(start, end).select(GPPbands, GPPband_names).map(function(img){return img.clip(Area)}); 
  var GPPIndices  = GPPfiltered.select('GPP');

  // Getting the multispectral imagery dataset in a defined temporal window.
  var LSTfiltered = LST.filterDate(start, end).select(LSTbands, LSTband_names).map(function(img){return img.clip(Area)}); 
  var LSTIndices  = LSTfiltered.select('LST');

 // Scale to Kelvin and convert to Celsius, set image acquisition time.
  var LSTIndices = LSTIndices.map(function(img) {
  return img
    .multiply(0.02)
    .subtract(273.15)
    .copyProperties(img, ['system:time_start']);
  });

  var GPP_LST_Indices = ee.ImageCollection(GPPfiltered.combine(LSTIndices));
    // var AllIndices = ee.ImageCollection(SpectralIndices.combine(GPPIndices).combine(LSTIndices));
  print('Second check of image collection - Habitat Metrics:', GPP_LST_Indices);

// Sub-step 3: Extract the data.
  // The telemetry SpatialPointsDataframe is used to filter the image collection.
  // The filtering process is based on the temporal resolution of the timestamp.
  
  var ExtractedPoints = points.map(function(feature){
  
  // Calling the date for each SpatialPointsDataframe feature.
  var date = ee.Number(feature.get('timestamp2'));
  
  // Converting the temporal data in a legible format (e.g., YYYY/MM/dd). 
  // (https://developers.google.com/earth-engine/apidocs/ee-date-parse)
  date = ee.Date.parse('YYYY/MM/dd', date);
  
  // Determining the size of sub-temporal windows for searching the multispectral imageries.
  var startTempWind = date.advance(-4,'days');
  var endTempWind = date.advance(4,'days');
  
  // Applying the sub-temporal windows and getting the closest temporal information between 
  // telemetry data and multispectral imageries.
  var FiltTempWind = GPP_LST_Indices.filterDate(startTempWind, endTempWind)
  .sort("CLOUD_COVER").mean();
  
  // Extracting the remotely sensed information using the SpatialPointsDataframe feature.                    
  var data = FiltTempWind.reduceRegion(ee.Reducer.mean(), feature.geometry(), 250);
  
  return ee.Feature(feature.setMulti(data));
  });
  
// Sub-step 4: Retrurn a SpatialPointsDataframe with remotely sensed information.
  // Calling the original SpatialPointsDataframe.
  var OriginalSpatialPointsDataframe = points;
  
  // Calling the extracted SpatialPointsDataframe.
  var ExtractedSpatialPointsDataframe = ee.FeatureCollection(ExtractedPoints);
  
  // Defining the matching field between the two collections.
  var JoinFilter = ee.Filter.equals({
  leftField: 'ID',
  rightField: 'ID'
  });
  
  // Defining the join parameter.
  var ParJoin = ee.Join.inner('primary', 'secondary');
  
  // Applying the parameter to concatenate the two collections.
  var DataframeJoin = ParJoin.apply(OriginalSpatialPointsDataframe, ExtractedSpatialPointsDataframe,  JoinFilter);
  
  // Collapsing the ExtractedSpatialPointsDataframe into the OriginalSpatialPointsDataframe.
  function CollapsJoin(feature){
  return ee.Feature(feature.get('primary')).copyProperties(feature.get('secondary'));
  }
  
  // Applying the collapse function.
  var DataframeJoin = DataframeJoin.map(CollapsJoin);
  print('Check the first row of the SpatialPointsDataframe:', DataframeJoin.first());
  
  // Exporting the SpatialPointsDataframe to a SHP file.
  Export.table.toDrive({
  collection: DataframeJoin,
  description:'MODIS_PA_GPP_LST_2017',
  fileFormat: 'SHP'
  });